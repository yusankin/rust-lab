## 文字列型一覧

|型名|読み方|特徴・用途|
|--|--|--|
|&str|スライスのstr（ストラ）|借用された文字列スライス（不変）|
|String|ストリング|可変の文字列。所有権あり|
|char|キャラ|1文字（Unicodeスカラー値）|
|u8|ユーエイト|1バイトの整数。文字として使うときは「バイト列」|
|Vec<u8>|ベクタ・ユーエイト|バイトの列。バイナリデータ、UTF-8の生データ|
|std::ffi::OsString|オスストリング|OS依存の文字列（WindowsとUnixでバイト列が違う）|
|std::ffi::OsStr|オスストラ|&str のOS版。OsStringの参照|
|CString|シーストリング|C言語互換の文字列。\0（ヌル終端）あり|
|CStr|シーストラ|CStringの参照版|
|&[u8]|ユーエイトスライス|生のバイト列スライス（ファイルIOや通信でよく使う）|

### よく使う文字列周り

| 型 | 意味 | よく使う場面 |
|----|------|--------------|
| `&str` | 借用された文字列（読み取り専用） | 関数引数などで使う |
| `String` | 自分が所有する文字列（可変） | 書き換え・所有・作成したいとき |
| `char` | 1文字（Unicode） | 文字の1つ1つを処理したいとき |

### バイト列（＝中身は文字とは限らない）

| 型 | 意味 | 用途 |
|----|------|------|
| `u8` | 1バイト整数 | 文字のバイト表現などに使う |
| `Vec<u8>` | バイト列 | 画像、ファイル、文字列のUTF-8表現など |
| `&[u8]` | バイト列の参照 | ネットワーク・ファイルIOでよく使う |

### OSやC言語との橋渡し

| 型 | 意味 | 用途 |
|----|------|------|
| `OsString` / `OsStr` | OSが理解できる文字列 | ファイルパス、コマンド名など |
| `CString` / `CStr` | C言語の文字列 | FFI（Cライブラリとのやりとり）で使う |

### 最後に：どれを使えばいいの？

| 使いたいもの | 使う型 |
|--------------|--------|
| 普通の文字列 | `String`（作成・所有）、`&str`（借用） |
| 1文字ずつ処理 | `char` |
| バイナリデータ | `Vec<u8>` or `&[u8]` |
| ファイル名・パス | `OsString` / `OsStr` |
| C言語とやり取り | `CString` / `CStr` |

## それぞれを超簡単に解説！

### &str（ストラ）

「借り物の文字列」  
実体は「UTF-8のバイト列を参照してるだけ」  
例： "hello" や fn hello(s: &str) みたいなやつ  

```rust
fn say(s: &str) {
    println!("{}", s);
}
```

### String

「自分で持ってる文字列（所有権あり）」  
String → &str に変換できる（.as_str() など）
可変（追加・削除できる）  

```rust
let mut s = String::from("hello");
s.push_str(" world");
```

### char

「1文字」だけど、実は4バイト持つことがある  
Unicodeの1文字（≠ 1バイト！）  
'あ' や 'a' など  

```rust
let c: char = '漢';
```

### u8 / Vec<u8> / &[u8]

u8: 1バイト整数（0〜255）  
Vec<u8>: バイナリデータの列  
&[u8]: その参照  

``` rust
let b: Vec<u8> = vec![72, 101, 108, 108, 111]; // "Hello" のバイト列
```

これを String に変換するには String::from_utf8(b) が必要（UTF-8保証あり）

### OsString / OsStr

OSによって文字コードの扱いが違うので、String じゃなく OsString を使う必要がある場面あり（特にパスとか）  
例：std::env::args_os() は OsString で返ってくる  

```rust
use std::ffi::OsString;
let os_string = OsString::from("ファイル名");
```

### CString / CStr

C言語では文字列が \0 で終わっている（ヌル終端）  
それをRust側で扱いたいときに使う  

```rust
use std::ffi::CString;
let c_string = CString::new("hello").unwrap(); // ヌルバイト含まない文字列だけOK
```